namespace win.ui.ctrl; 
import win.ui.ctrl.metaProperty;//导入控件属性元表支持

//文本控件用到的结构体
var CHARRANGE = class {
	int cpMin;
	int cpMax;
}
var TEXTRANGE = class {
	struct	chrg = {
		int cpMin;
		int cpMax;
	};
	string	lpstrText;
}
 
//这里我们使用一个反向的装饰继承类来封装edit与richedit控件的公用属性
class editDecorateMeta{
	ctor(meta)begin
		this = meta
	end; 
	
	//公用属性
	//--------------------------------------
	
	modified = {
		_get = function(){ 
			return  ::SendMessage(owner[["hwnd"]],0xB8/*_EM_GETMODIFY*/);
		}
		_set = function( v ){
			::SendMessageInt(owner[["hwnd"]],0xB9/*_EM_SETMODIFY*/,0,v );
		} 	
	};  
	//公用方法
	//--------------------------------------
	getsel = function(){
      //获取起始和结束位置
      var re,min,max = ::SendMessageRefInt(owner[["hwnd"]],0xB0/*_EM_GETSEL*/,0,0); 
      return  min,max  ;  
    }
    setsel = function(min=0,max=0){ 
     	//获取起始和结束位置
        ::SendMessageInt(owner[["hwnd"]],0xB1/*_EM_SETSEL*/,min ,max);
    }  
    rangeText = function(min,max){
    	var rg = TEXTRANGE();
		rg.chrg.cpMin = min;
		rg.chrg.cpMax = max;
		rg.lpstrText = ..raw.malloc(max-min+1)
		::SendMessageByStruct(owner.hwnd, 0x44B/*_EM_GETTEXTRANGE*/, 0, rg); 
		return rg.lpstrText
    }
    lineCount = {
		_get = function(){ 
			return  ::SendMessage(owner[["hwnd"]],0xBA/*_EM_GETLINECOUNT*/);
		} 	
	};
    lineText = function(ind){
		ind--;
		var len = ::SendMessage(owner[["hwnd"]],0xC1/*_EM_LINELENGTH*/,topointer(ind)) * 3;
		var buffer = ..raw.toarray( len + 1,"INT" )  
		 
		buffer.array  = { len };//Before sending the message, set the first word of this buffer to the size, in TCHARs, of the buffer
		::SendMessageByStruct(  owner[["hwnd"]],0xC4/*_EM_GETLINE*/,ind,buffer);
		
		return ..string.str(..raw.tostring(buffer));
    }
    lineFromChar = function(pos){
       pos--;
       return  ::SendMessage(owner[["hwnd"]],0xC9/*_EM_LINEFROMCHAR*/,topointer(pos) ); 
    }
    lineToChar = function(line){
       line--;
       return  ::SendMessage(owner[["hwnd"]],0xBB/*_EM_LINEINDEX*/,topointer(line), ); 
    }
    lineScroll = function(line=0,h=0){ 
       ::SendMessageInt(owner[["hwnd"]],0xB6/*_EM_LINESCROLL*/,h,line-1 );       
    }
    scrollCaret = function(){
       ::SendMessage( owner[["hwnd"]] , 0xB7/*_EM_SCROLLCARET*/);
    } 
}
 


class edit{

    //构造函数
    ctor(parent,tvalue){
		if(tvalue){
			if( tvalue.readonly )
				tvalue.style |= 0x800/*_ES_READONLY*/
				
			if( tvalue.password )
				tvalue.style |= 0x20/*_ES_PASSWORD*/
			else if( tvalue.multiline ){
				tvalue.style |= 0x4/*_ES_MULTILINE*/
				tvalue.style |= 0x1000/*_ES_WANTRETURN*/;
			}
			
	    	if( tvalue.number )
	    		tvalue.style |=0x2000/*_ES_NUMBER*/
	    		
			if(! tvalue.hidesel )
				tvalue.style |= 0x100/*_ES_NOHIDESEL*/
				
			//输入时文本框自动向右，向下滚动
			tvalue.style |=  ( 0x80/*_ES_AUTOHSCROLL*/ |  0x40/*_ES_AUTOVSCROLL*/ )
			
			tvalue.bgcolor := 16777215;
	
        	select(tvalue.align) {
			case  "center"   
	   		tvalue.style |= 0x1/*_ES_CENTER*/; 
			case "right" 
	   		tvalue.style |= 0x2/*_ES_RIGHT*/; 
			else 
			tvalue.style |= 0x0/*_ES_LEFT*/;
			}
 	
			if(tvalue.edge)   
				tvalue.exstyle |= 0x200/*_WS_EX_CLIENTEDGE*/;   
		}
	
    }
    
	@metaProperty;
}
edit.metaProperty = editDecorateMeta( ..win.ui.ctrl.metaProperty(
	limit = {
		_get = function(){ 
			return ::SendMessage(owner[["hwnd"]], 0x425/*_EM_GETLIMITTEXT*/, null , null);
		}
		_set = function( v ){
			assert( type(v) == type.number )
     		::SendMessage(owner[["hwnd"]], 0xC5/*_EM_LIMITTEXT*/, topointer(v) , null)
		} 	
	}  
	) );


/***intellisense()

!edit.lineCount = 获取行数
!edit.setsel(1,__) = 设置选区,参数(起始位置,结束位置)
!edit.getsel() = 获取选区起始位置,结束位置 
!edit.modified = 文本内容是否已修改 
!edit.text = 编辑控件文本属性
!edit.hwnd = 控件句柄
!edit.id = 控件ID
!edit.parent = 父窗口
!edit.parent.hwnd = 父窗口句柄
!edit.hide = 控件是否隐藏
!edit.disabled = 控件时否可见
!edit.left = 左侧坐标
!edit.right = 右侧坐标
!edit.top = 顶部坐标
!edit.bottom = 底部坐标
!edit.limit = 字符数限制
!edit.scrollCaret = 滚动到光标处
!edit.lineScroll(.(滚动到指定行) = 滚动条移动到指定行
!edit.lineScroll(.(滚动指定行,列) = 滚动条移动到指定行 
!edit.lineToChar = 获取指定行首字符偏移位置
!edit.lineFromChar = 返回指定位置行数
!edit.lineText = 获取指定行文本
!edit.redraw() = 刷新
!edit.show(true__) = 显示控件
!edit.rect = 控件区块位置(::RECT结构体)
!edit.clientRect =  控件客户区块位置(::RECT结构体)
!edit.font = 控件字体(::LOGFONT结构体)
!edit.clientRect =  获取控件客户区块位置(::RECT结构体)
!edit.theme = 外观主题,例如\nwinform.button.theme = "Explorer"\nwinform.button.theme = false
!edit.modifyStyle(.(remove,add) = 如果指定第三个参数，则使用此参数调用::SetWidnowPos 
!edit.modifyStyleEx(.(remove,add) = 如果指定第三个参数，则使用此参数调用::SetWidnowPos
!edit.capture = 是否捕获全局鼠标消自息
!edit.close() = 关闭控件窗
!edit.invalidate(__/*可选使用::RECT()对象指定客户区*/) = 使窗口绘图区无效
!edit.invalidate(__/*可选使用::RECT()对象指定客户区*/,0) = 使窗口绘图区无效\n不刷新背景
!edit.update() = 重绘invalidate函数指定的区块
!edit.wrap = 是否启用自动换行，仅richedit支持
!edit.onlink = @.onlink=function(msg,title){\n	\n}
!edit.setFocus() = 设置焦点
!edit.setFocus() = 设置焦点 
!edit.setPos(.(x坐标,y坐标,宽,高,插入位置,参数) = 调整窗口位置或排序,所有参数可选\n同时指定x,y坐标则移动位置\n同时指定宽高则改变大小\n指定插入位置(句柄或_HWND前缀常量)则调整Z序
!edit.getPos() = 返回相对坐标,宽,高\nx,y,cx,cy=win.getPos(hwnd)
?win.ui.ctrl.edit  =!edit.  
end intellisense***/