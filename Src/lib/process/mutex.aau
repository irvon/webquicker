namespace process;

class mutex {
	ctor( uniqueName,inheritHandle ){
	
		assert(type(uniqueName)== type.string,"参数一必须是字符串")
		if(type(inheritHandle===null) )inheritHandle=0x1/*_TRUE*/;
		 
		
		//检查互斥体
		this.handle  =  OpenMutex( 0x000F0000|0x00100000|0x0001 /* MUTANT_ALL_ACCESS*/,inheritHandle,uniqueName);  
		if(this.handle ) {
    		this.conflict = "互斥体已存在,不能重复创建!" 
    	}
		else{
			//创建互斥体 
			this.handle  =  CreateMutex(null,inheritHandle,uniqueName); 
		}

	};
	
	close = function(){
		if(this.conflict)
			ReleaseMutex(this.handle);
		
		..raw.closehandle(this.handle)
	} 
}


namespace mutex{

	//声明API
	OpenMutex = ::Kernel32.api("OpenMutexA","pointer(
	INT dwDesiredAccess,
	int bInheritHandle,
	string lpName)"
	);
	
	
	//声明API
	CreateMutex = ::Kernel32.api("CreateMutexA","pointer(pointer lpMutexAttributes,
	int bInitialOwner,
	string lpName)"
	);
	 
	ReleaseMutex= ::Kernel32.api("ReleaseMutex","int(
  	pointer handle
	)");


}
 
/**intellisense() 
process.mutex("互斥体唯一名称") = @mutex=process.mutex("__/*输入唯一标识字符串\n建议使用GUID生成Globally Unique Identifier(全球唯一标识符) */")\nif( mutex.conflict ){\n	io.print("互斥体已存在","句柄:"+mutex.handle)\n}\nmutex.close();
!mutex.close()=关闭互斥体
!mutex.handle=创建或打开的互斥体句柄
!mutex.conflict = 互斥体冲突状态
?process.mutex=!mutex.
end intellisense**/
