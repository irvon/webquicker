//窗口库 
//注释//注释描述 
var u = ::User32;
var k = ::Kernel32;

//取高位、低位、合并
/*intellisense(::)*/
::LOWORD = function(l) {return l & 0xffff }
::HIWORD = function(l) {return  (l >> 16) & 0xffff }
::MAKELONG = function(a,b){ return ( ( (b & 0xFFFF) << 16) | (a & 0xFFFF) ) & 0xFFFFFFFF } 
::LOBYTE = function(l) {return l  & 0xff }
::HIBYTE = function(l) {return   (l   >> 8) & 0xff  }
::MAKEWORD = function (a,b){ return ( ( ( b & 0xFF) << 8) | ( a & 0xFF) ) & 0xFFFF  } 
/*end intellisense*/

/*intellisense(::)
::MAKELPARAM = @MAKELONG(__,)
::MAKEWPARAM = @MAKELONG(__,)
end intellisense*/
 
//结构体
 /*intellisense(::)*/
 
::MSG = class{ 
    int hwnd;
    INT message;
    int wParam;
    int lParam;
    INT time;

    struct pt = {
    	INT x;
    	INT y;
    }; 
}  

::RECT = class{
	ctor(left=0,top=0,right=0,bottom=0){
  		this.left = left;
  		this.top = top;
  		this.right = right;
  		this.bottom = bottom;
	} 
	int left;
	int top;
	int right;
	int bottom;
}

::POINT = class{
   ctor(x=0,y=0){
      this.x = x;
      this.y = y;
   } 
   int x ; 
   int y ;
}

::SIZE = class{
	int cx=0;
	int cy=0;
}
  

//系统 API
::GetModuleHandle = k.api( "GetModuleHandleA", "pointer(string)")  
::GetSystemMetrics = u.api("GetSystemMetrics","int(int)") 
::CreateWindowEx = u.api( "CreateWindowExA", " int(INT dwExStle,string IpClassName,string lpWindowName,INT dwStyle,int x,int y,int nWidth,
					int nHeight,int hWndParent,int hMenu,pointer hlnstance,pointer lpParam)" )  
::DestroyWindow = u.api( "DestroyWindow", "int(int hWnd )" );	
				
//窗口 API
::CallWindowProc = u.api("CallWindowProcA","int(pointer lpPrevWndFunc,int hWnd,INT Msg,int wParam,int lParam)" )
::SetWindowPointer = u.api("SetWindowLongA","pointer(int hWnd,int nIndex,pointer ptrNew)" ) 
::SetWindowLong = u.api("SetWindowLongA","int(int hWnd,int nIndex,int dwNewLong)" )
::GetWindowLong = u.api("GetWindowLongA","int(int hWnd,int nIndex)" ) 
::UpdateWindow = u.api( "UpdateWindow", " int(int) " ) 
::InvalidateRect = u.api( "InvalidateRect", " int(int hWnd,struct lpRect,int bErase) " )  
::RedrawWindow = u.api("RedrawWindow","int(int hwnd,struct lprcUpdate,pointer hrgnUpdate,INT flags)");
::GetWindowRect = u.api( "GetWindowRect", " int(int hWnd,struct &lpRect ) " )
::GetClientRect = u.api( "GetClientRect", " int(int hWnd,struct &lpRect ) " )
::ScreenToClient = u.api( "ScreenToClient", " int(int hWnd,struct &lpPoint ) " )
::ClientToScreen = u.api( "ClientToScreen", " int(int hWnd,struct &lpPoint ) " )
::OffsetRect = u.api( "OffsetRect", "int( struct &lprc, int dx, int dy )" );
::PtInRect = u.api( "PtInRect", "int(struct, int, int)" );
::MoveWindow = u.api( "MoveWindow", "int( int hWnd, int X,int Y,int nWidth,int nHeight, int bRepaint)" )  
::SetWindowPos = u.api("SetWindowPos","boolean(int hWnd,int hWndlnsertAfter,int X,int Y,int cx,int cy,int Flags)")

//消息 API
::RegisterWindowMessage = u.api("RegisterWindowMessageA","int(string)");
::PostMessage = u.api("PostMessageA","int(int hWnd,INT msg,int wParam,int lParam)")
::PostThreadMessage = u.api("PostThreadMessageA","int(int idThread,INT msg,int wParam,int lParam)"); 
::SendMessage = u.api("SendMessageA","int(int hWnd,INT msg,pointer wParam,pointer lParam)")
::SendMessageInt = u.api("SendMessageA","int(int hWnd,INT msg,int wParam,int lParam)")
::SendMessageRefInt = u.api("SendMessageA","int(int hWnd,INT msg,int &wParam,int &lParam)")
::SendMessageByString = u.api("SendMessageA","int(int,INT,int,string &bin)")
::SendMessageByStr = u.api("SendMessageA","int(int,INT,int,str &text)")
::SendMessageByStruct = u.api("SendMessageA","int(int,INT,int,struct &)") 
::SendMessageTimeout = u.api("SendMessageTimeout","int(int hwnd,INT Msg,int wParam,int IParam,INT fuFlags,INT uTimeout,int & lpdwResultult)") 
 
 //图像 API
::LoadImage = u.api(  "LoadImage", "ptr(ptr,string,INT uType,int cxDesired,int CyDesire,INT fuLoad)") 
::CopyImage = u.api(  "CopyImage", "ptr(ptr handle, INT uType,int cx,int cy,INT flags)") 
::LoadBitmap = u.api(  "LoadBitmap", "ptr(ptr,string)")  
::LoadIcon = u.api(  "LoadIconA", "ptr(ptr,string)")      

//内存 API
::GlobalAlloc = k.api("GlobalAlloc","pointer(INT,INT)" ) ;
::GlobalLock = k.api("GlobalLock","ponter(pointer)" ) ;
::GlobalUnlock = k.api("GlobalUnlock","ponter(pointer)" ) 
::GlobalFree = k.api("GlobalFree","void(pointer)" )


/*end intellisense*/

//封装函数
//----------------------------------------------

namespace win

//windows回调函数
CALLBACK = {  
 /*intellisense(win.CALLBACK)*/
WNDPROC ="int32(int32 hwnd,INT32,int32,int32)";
DLGPROC ="int32(int32 hwnd,INT32,int32,int32)";
TIMERPROC ="void(int32 hwnd,INT32,INT32,INT32)";
GRAYSTRINGPROC ="int32(ptr,int32,int32)";
WNDENUMPROC ="int32(int32 hwnd,int32 lParam)";
HOOKPROC ="int32(int32,int32 wParam,int32 lParam)";
SENDASYNCPROC ="void(int32,INT32,INT32,int32)";
PROPENUMPROCA ="int32(int32,string,ptr)";
PROPENUMPROCW ="int32(int32,string,ptr)";
PROPENUMPROCEX ="int32(int32,string,ptr,INT32)";
EDITWORDBREAKPROC ="int32(string lpch,int32 ichCurrent,int32 cch,int32 code)";
DRAWSTATEPROC ="int32(ptr,int32,int32,int32,int32)"; 
/*end intellisense*/
} 

/*intellisense(win)*/
GetWindow = u.api( "GetWindow", "int( int hWnd,INT uCmd)" )
/*end intellisense*/

//样式
getStyle = function(hwnd,style=~0){
	return ::GetWindowLong(hwnd,0xFFFFFFF0/*_GWL_STYLE*/) & style
}
getStyleEx = function(hwnd,style=~0){
	return ::GetWindowLong(hwnd,0xFFFFFFEC/*_GWL_EXSTYLE*/) & style
} 
modifyStyle = function(hwnd,remove=0,add=0,flags,gwl=0xFFFFFFF0/*_GWL_STYLE*/ ){
	var style = ( ::GetWindowLong(hwnd,gwl) & ~remove ) | add ; 
	::SetWindowLong(hwnd,gwl,style )
	if(flags!==null)
		::SetWindowPos(hwnd,0,0,0,0,0,flags | 0x1/*_SWP_NOSIZE*/ | 0x2/*_SWP_NOMOVE*/ | 0x4/*_SWP_NOZORDER*/ | 0x10/*_SWP_NOACTIVATE*/)
	return style
}
modifyStyleEx = function(hwnd,remove,add,flags){
	return modifyStyle( hwnd,remove,add,flags,0xFFFFFFEC/*_GWL_EXSTYLE*/)
}

getParent = u.api( "GetParent", "int(int hwnd)" )   
setParent = u.api("SetParent","int(int hWndChild,int hWndNewParent)");

//获取设置窗口文本
getText = function(hwnd,len){
	//返回窗体文本
	len := ::SendMessage(hwnd,0xE/*_WM_GETTEXTLENGTH*/,null,null) + 1; 
	var re, textBuf = ::SendMessageByStr(hwnd,0xD/*_WM_GETTEXT*/,len,len);  
	return textBuf;  
}
setText = u.api( "SetWindowText", "INT(int hwnd,string lpString )" ) 

//根据控件ID读取或设置文本
var getDlgItemText = u.api( "GetDlgItemTextA", "INT(int hDlg,int nIDDlgItem, str& lpString, int cchMax)" )  
getTextById = function(hwnd,id,len=256){  
	var re, textBuf = getDlgItemText(hwnd,id,len,len);
	return textBuf ;  
}
setTextById = u.api( "SetDlgItemTextA", "INT(int hDlg,int nIDDlgItem, string lpString )" )  
  
//返回窗口ID
getId = function(hwnd){ 
	return ::GetWindowLong(hwnd,0xFFFFFFF4/*_GWL_ID*/ )
}

//返回窗口类名
var getClassName = u.api( "GetClassNameA", "int( int hWnd,str  &lpClassName,int nMaxCount )" )  
getClass = function(hwnd){
	var re,classname　= getClassName(hwnd,0x64 ,0x64/*_MAX_CLASS*/); 
	return classname ;
}
 
//返回顶层窗口句柄
getRoot = function(hwnd){ 

    var result;
    do{
    	result = hwnd;
    	hwnd = getParent(hwnd)
    }while(hwnd) 
    
    return result; 
} 


getLeaf = function(hwnd){
	var result;
    do{
    	result = hwnd;
    	hwnd = GetWindow(hwnd,0x5/*_GW_CHILD*/)
    }while(hwnd) 
    
    return result;
}
getChild = function(hwnd){
	return GetWindow(hwnd,0x5/*_GW_CHILD*/);
}


var getThreadProcessId_c = u.api( "GetWindowThreadProcessId", "INT(int hWnd,INT & lpdwProcessId)" ) ;
getThreadProcessId = function(hwnd){ 
	return getThreadProcessId_c(hwnd,0);
}

var getEnvironmentVariable = k.api( "GetEnvironmentVariableA", "INT(string lpName,string &lpBuffer,INT nSize)");
var setEnvironmentVariable = k.api( "SetEnvironmentVariableA", "INT(string lpName,string  lpValue )"); 
getenv = function( name){ //读取环境变量
	var len,val =  getEnvironmentVariable(name, 256,256);
	if (len > 256)
		len,val =  getEnvironmentVariable(name, len,len); 
	return val;
}
setenv = function( name,val){ //设置环境变量
	return setEnvironmentVariable(name, val);
}

//win.lasterr已废弃,请使用全局函数 ..lasterr
self.lasterr  = ..lasterr

/**intellisense(win)
getStyle(__/*输入窗口句柄*/) = 获取窗口样式
getStyle(__/*输入窗口句柄*/,0) = 获取指定窗口样式\n返回值非零并与指定样式相同、则窗口具有指定样式
getStyleEx(__/*输入窗口句柄*/) = 获取窗口扩展样式
getStyleEx(__/*输入窗口句柄*/,0) = 获取指定窗口扩展样式\n返回值非零并与指定样式相同、则窗口具有指定样式
modifyStyle(.(窗口句柄,移除样式,添加样式) = 如果指定第三个参数，则使用此参数调用::SetWidnowPos 
modifyStyleEx(.(窗口句柄,移除样式,添加样式) = 如果指定第三个参数，则使用此参数调用::SetWidnowPos
getClass(__/*输入窗口句柄*/) = 获取窗口类名
getId(__/*输入窗口句柄*/) = 获取控件ID
getRoot(__/*输入窗口句柄*/) = 获取顶层窗口句柄
getLeaf(__/*输入窗口句柄*/) =　窗口的最梢节子窗口(没有子窗口的控件窗口)
getRoot(__/*输入窗口句柄*/) = 获取顶层窗口句柄
getParent(__/*输入窗口句柄*/) = 获取父窗口句柄
setParent(.(子窗口句柄,父窗口句柄)=设置父窗口
getChild(__/*输入窗口句柄*/) = 获取子窗口句柄 
getText(__/*输入窗口句柄*/,20) = 获取窗口文本,并指定缓冲区大小
getText(__/*输入窗口句柄*/) = 获取窗口文本
setText(.(hwnd,lpString) = 参数(窗口句柄,要设置的文本)
getThreadProcessId(__/*输入窗口句柄*/) = 返回线程ID,进程ID\nvar tid,pid=win.getThreadProcessId(hwnd)
getTextById(.(hwnd,id,len=256) = 获取窗口上控件的文本\n参数(窗口句柄,控件ID，缓冲区大小)
setTextById(.(hwnd,id,str) = 设置窗口上控件的文本\n参数(窗口句柄,控件ID，文本)
getenv("__") = 读取环璋变量
setenv("__","") = 设置环境变量
lasterr() = win.lasterr已废弃,请使用全局函数 ..lasterr
end intellisense**/
   
//窗口查找
getDesktop = u.api( "GetDesktopWindow", "int()" ) 
setTop = u.api("BringWindowToTop","boolean(int hWnd)")  
getActive = u.api("GetActiveWindow","int()") 
setActive = u.api("SetActiveWindow","int(int hwnd)") 
getFocus = u.api("GetFocus","int()");
setFocus = u.api("SetFocus","int(int hwnd)");
enable = u.api("EnableWindow","int(int hwnd,bool enable)") 
close = function(hwnd){ 
	::SendMessage(hwnd,0x10/*_WM_CLOSE*/);
} 
var showWindow = u.api( "ShowWindow", "int(int,int)" )  
show = function(hwnd,flag=true) {   
	showWindow( hwnd,flag===true ? 0x5/*_SW_SHOW*/ : tonumber(flag) ); 
}
findEx = u.api( "FindWindowExA", "int(int hWndParent,int hWndChildAfter,string lpszClass,string lpszWindow)" )  
find = u.api( "FindWindowA", "int( string lpszClass,string lpszWindow)" ) 

setTopmost = function(hwnd,top=true){
	 ::SetWindowPos(hwnd,(top)?-1/*_HWND_TOPMOST*/:-2/*_HWND_NOTOPMOST*/,0,0,0,0,0x2/*_SWP_NOMOVE*/|0x1/*_SWP_NOSIZE*/) 
} 

//try{
	SwitchToThisWindow = u.api( "SwitchToThisWindow", "int(int hwnd,int bRestore)" )  
	setForeground = function(hwnd,restore=1){
		return SwitchToThisWindow(hwnd,restore);
	}	
/*
}
catch(e){
	setForeground = u.api("SetForegroundWindow","int(int hwnd)") 
} 
*/
getForeground = u.api( "GetForegroundWindow", "int()" )
		
isVisible = u.api("IsWindowVisible","int(int hwnd)")
isWindow = u.api( "IsWindow", "int(int hwnd)" )    
isIconic = u.api( "IsIconic", "int(int hwnd)" )  
isZoomed = u.api("IsZoomed","int(int hwnd)") 	
isEnable = function(hwnd){
	return ! getStyle(hwnd,0x8000000/*_WS_DISABLED*/ )
} 
isChild = ::User32.api("IsChild","int(int parent,int hwnd)")

/**intellisense(win)   
isChild(.(父窗口句柄,子窗口句柄) = 判断参数二指定的窗口是否参数一指定窗口的子窗口或隶属子窗口
isVisible(__/*输入窗口句柄*/) = 判断窗口是否可见
isWindow(__/*输入窗口句柄*/) = 判断是否有效窗口
isIconic(__/*输入窗口句柄*/) = 判断窗口是否最小化为任务栏图标
isZoomed(__/*输入窗口句柄*/) = 判断窗口是否最大化
isEnable(__/*输入窗口句柄*/) = 判断窗口是否启用状态
show(hwnd,__/*可选输入显示参数*/) = 显示窗口,可选输入以_SW_为前缀的显示参数
show(hwnd,false) = 隐藏窗口
close(__/*输入窗口句柄*/) = 关闭窗口
enable(__/*输入窗口句柄*/,true) = 启用窗口
enable(__/*输入窗口句柄*/,false) = 禁用窗口
setTop(__/*输入窗口句柄*/)=前置窗口到当前线程Z序顶部
setForeground(__/*输入窗口句柄*/)=前置窗口
getForeground()=获取前台窗口句柄
getActive()=获取当前线程激活窗口句柄,如果要获取全局激活窗口请使用win.getForeground()
setActive(__/*输入窗口句柄*/)=设置激活窗口
getFocus()=获取窗入焦点所在窗口句柄
setFocus(__/*输入窗口句柄*/)=设置输入焦点
getDesktop()=获取桌面句柄
setTopmost(__/*输入窗口句柄*/)=置顶窗口
setTopmost(__/*输入窗口句柄*/,false)=取消置顶窗口
find(.(类名,标题)=查找顶层窗口，参数都是可选参数
findEx(.(父窗口句柄,上一个窗口句柄,类名,标题)=查找子窗口\n除父窗口句柄以外，其他参数都是可选参数 
end intellisense**/ 


setPos = function(hwnd,x,y,cx,cy,after,flag=0){
	if( (x===null) || (y===null) ){
	   flag |= 0x2/*_SWP_NOMOVE*/
	   x,y = 0,0;
	}
	   
	if( (cx===null) || (cy===null) ){
	   flag |= 0x1/*_SWP_NOSIZE*/
	   cx,cy = 0,0;
	}
	  
	if( after === null ){
	   flag |= 0x4/*_SWP_NOZORDER*/
	   after = 0;
	} 
	SetWindowPos(hwnd,after,x,y,cx,cy,flag);
}

//ptConv不得传出外部
var ptConv = POINT();
toScreen = function(hwnd,x,y){
	ptConv.x = x;
	ptConv.y = y;
	ClientToScreen(hwnd,ptConv);
	return ptConv.x,ptConv.y;
}
toClient = function(hwnd,x,y){
	ptConv.x = x;
	ptConv.y = y;
	ScreenToClient(hwnd,ptConv);
	return ptConv.x,ptConv.y;
}
var converRect = function(conv,parent,rc){
	ptConv.x = rc.right; 
	ptConv.y = rc.bottom;
	conv( parent,rc );
	conv( parent,ptConv );
	rc.right = ptConv.x;
	rc.bottom = ptConv.y;
	return rc;
}
toScreenRect = function(parent,rc){
	return converRect( ClientToScreen,parent,rc );
}
toClientRect = function(parent,rc){
	return converRect( ScreenToClient,parent,rc );
}

//返回窗口的相对坐标 
getRect  = function(hwnd,scr){  
	var rc = RECT();
	GetWindowRect( hwnd,rc); 
	if( scr ) 
		return rc;
	  
	var parent = ..win.getParent(hwnd)
	if( parent ) 
		toClientRect( parent,rc ); 
	 
	return rc; 
}
getClientRect = function(hwnd){
	var rc = RECT();
	GetClientRect( hwnd,rc); 
	return rc;
}
setRect = function(hwnd,rc){
	setPos(hwnd,rc.left,rc.top,rc.right-rc.left,rc.bottom-rc.top)
}
getPos = function(hwnd,scr){
	var rc = getRect(hwnd,scr);
	return rc.left, rc.top, rc.right - rc.left ,rc.bottom - rc.top 
}


/**intellisense()
?.getRect = !rect.
!rect.left = 左
!rect.top = 上
!rect.right = 右
!rect.bottom = 下
!point.x = x坐标
!point.y = y坐标
?::RECT = !rect.
?::RECT = !point.
end intellisense**/

/**intellisense(win)
toScreen(__/*输入窗口句柄*/,x,y) = 将坐标转换为屏幕坐标\n::POINT结构体请直接使用::ClientToScreen
toClient(__/*输入窗口句柄*/,x,y) = 将坐标转换为客户坐标\n::POINT结构体请直接使用::ScreenToClient
toScreenRect(__/*输入窗口句柄*/,rc) = 将::RECT结构体转换为屏幕坐标
toClientRect(__/*输入窗口句柄*/,rc) = 将::RECT结构体转换为客户坐标
getRect(__/*输入窗口句柄*/) = 返回窗体相对坐标位置\n对于顶层窗口则等同于屏幕绝对坐标位置\n如需返回屏幕坐标,可以直接使用 ::GetWindowRect
getRect(__/*输入窗口句柄*/,true) = 返回窗体屏幕坐标位置\n返回值为::RECT结构体
setRect(__/*输入窗口句柄*/,rc) = 设置窗口相对坐标位置
getClientRect(__/*输入窗口句柄*/) = 获取窗口客户区的坐标\n不包括边框等
setPos(.(窗口句柄,x坐标,y坐标,宽,高,插入位置,参数) = 调整窗口位置或排序,除句柄外所有参数可选\n同时指定x,y坐标则移动位置\n同时指定宽高则改变大小\n指定插入位置(句柄或_HWND前缀常量)则调整Z序
getPos(__/*输入窗口句柄*/) = 返回相对坐标,宽,高\nx,y,cx,cy=win.getPos(hwnd)
getPos(__/*输入窗口句柄*/,true) = 返回屏幕坐标,宽,高\nx,y,cx,cy=win.getPos(hwnd)
end intellisense**/

getScreen = function(){ 
	return ::GetSystemMetrics( 0x0 ),::GetSystemMetrics( 0x1 )
}  
/**intellisense(win)
getScreen() = 返回屏幕宽度、高度
end intellisense**/
 
 
var messageBox = u.api( "MessageBoxA", " int ( int hWnd, string lpText,string lpCaption ,INT uType )" )  
var messageBoxTimeout = u.api("MessageBoxTimeoutA","int(int hwnd,string lpText,string lpCaption,int uType,int wlange,int dwTimeout)","stdcall") ;

msgbox = function(str,title = "AAuto" ,style ,parenthwnd=0 ){ 
   style := 0x40 // _MB_OK|_MB_ICONINFORMATION;
    
   if(!parenthwnd)
    	style |= 0x2000/*_MB_TASKMODAL*/
    	
   return  messageBox( parenthwnd,tostring( str ) ,title,style | 0x10000/*_MB_SETFOREGROUND*/ );
}
msgboxTest = function(str,title ,parenthwnd=0){
	return msgbox(str,title,0x1 | 0x20 /*_MB_OKCANCEL|_MB_ICONQUESTION*/ ,parenthwnd ) == 1;	
}
msgboxTimeout = function(str,title = "AAuto" ,timeout =2000,style ,parenthwnd=0 ){
	style := 0x40 // _MB_OK|_MB_ICONINFORMATION;
	if(!parenthwnd)
    	style |= 0x2000/*_MB_TASKMODAL*/
	return  messageBoxTimeout( parenthwnd,tostring( str ) ,title,style | 0x10000/*_MB_SETFOREGROUND*/ ,0,timeout );
}
  
/*消息循环函数{{*/ 

	/*
	::TranslateAccelerator = u.api("TranslateAcceleratorA","int(int hWnd,int hAccTable,struct  lpMsg)");
	::CreateAcceleratorTable = u.api("CreateAcceleratorTableA","int(struct paccel,  int cAccel)");
	
	class ACCEL { 
		ctor(v,k,c){
		this.fVirt = v;this.key=k;this.cmd=c ;
		}
		WORD   fVirt;  
		WORD   key;
		INT  cmd; 
	}  
	*/ 
	isDialogMessage  = u.api("IsDialogMessage","INT(int hDlg,struct IpMsgc)");
	var isDialogMessage = isDialogMessage;
	
	var peekMessage = u.api(  "PeekMessage", "int(struct& lpMsg,int hwnd,INT wMsgFilterMin,INT wMsgFilterMax,INT wRemoveMsg)")   
	var getMessage = u.api( "GetMessage", " int(struct&,int,INT,INT) " )   
	var translateMessage = u.api( "TranslateMessage", " int(struct&) " )   
	var dispatchMessage = u.api( "DispatchMessage", " int(struct&) " )  
	
	var mapforms = { //键为控件名任意窗口句柄,值为容器form
		@{ _weak = "kv"}  //在元表中指定为弱引用，以自动清除不使用的元素
	}

	var msg_observer = {}
	var parseMessage = function(msg){
			if( msg_observer[[1]] ){
				for(k,v in msg_observer){
					var re = v(msg);
					if(  re !==null){ 
						return re;
					}
				}
				
			}
			
			var hwnd = msg.hwnd; 
			if( hwnd &&  ..win.ui ){
		    	var winform  = mapforms[hwnd] 
		    	if(  winform === null  ){
		    		winform = ..win.ui.getForm(hwnd)
		    		
		    	    if(!winform)
		            	mapforms[hwnd] = false; //标记为false,避免重复查询父窗口
		    		else 
		    		    mapforms[hwnd] = winform; 
		    		 
		    	}
		    	
		    	if( winform  ){   
		    		if(winform.pretranslate && winform.pretranslate(msg) )
		        		return true;
		        		
		        	if( (msg.message >= 0x100/*_WM_KEYFIRST*/) && (msg.message <= 0x108/*_WM_KEYLAST*/) ){ 
		        		var isdlg = winform[["isDialogMessage"]] : isDialogMessage;  
		        		if( isdlg( winform.hwnd,msg ) )
		    				return true;
		    		} 
		        }
	
			}
			
			translateMessage( msg); 
			dispatchMessage( msg); 
		 	
	}
	
		
	var msgloop;
		
	pumpMessage = function(){
		var msg = ::MSG();
		if( getMessage( msg,0,0,0) > 0 )
		{
			if(msg.message == 0x12 ){
				quitMessage(); 
				return null;
			}
			
			parseMessage(msg);
		}
		sleep(1)
	}
	
	/*
		启动消息循环，即使重复调用此函数，一个线程仅启动一个循环。
		
		参数：
		observer 消息观察函数，可以为null
		attach 为true则注册observer函数，为false则注销observer函数  
	*/
	loopMessage = function( observer ,attach=true){ //启动消息循环，参数为主窗体   
		if(type(observer) == type.function ){
			if( !attach ){
				for(i=#msg_observer;1){
					if( msg_observer[i] == observer){
						..table.remove(msg_observer,i);
						return true;
					}
				}
				return false;
			}
			..table.push(msg_observer,observer);
		}
		
		//排重
		if(msgloop)return;
		msgloop = true;
		
		..win.closed = null;
		
		var msg = ::MSG();
		while(   getMessage( msg,0,0,0) > 0    ) //GetMessage()函数会返回0，非0和-1。其中－1表示由于hWnd不是有效   的窗口句柄等原因而出错。 
		{    
			parseMessage(msg); 
	
		}
		
		msgloop = false;
		..win.closed = true;
		mapforms = {};//清空缓存里的所有窗口对象
		
		return  true; 
	}
	
	quitMessage = function(){
	::PostThreadMessage(..thread.getId(),0x12/*_WM_QUIT*/ ,0,0);
	..win.closed = true;  
	}
		
	
	var time_tick = ..time.tick;
	delay = function ( nTimeMs = 0 ) { 
		var msg = ::MSG();
		var endTick = time_tick() + nTimeMs;
		while(time_tick() < endTick)  
		{  
			if( closed )return false;
			
			if(peekMessage(msg , 0, 0, 0, 1)) {
				if(msg.message == 0x12 ){
					quitMessage();
					return false;
				}
				
				parseMessage(msg);
			}
			sleep(1)
		}
		return true;
	}
	
/*}}*/
 

/**intellisense(win) 
msgbox("__","AAuto") = 弹出对话框
msgboxTimeout("__","标题") = 弹出对话框，超时自动关闭
msgboxTimeout("__","标题",3000) = 弹出对话框，超时自动关闭
msgboxTest("",""); = @win.msgboxTest("询问用户的信息","标题")//返回布尔值表示用户是否按了“确定”按钮。 
closed = 用户是否关闭了全部窗口 
loopMessage(__) = 运行消息循环
quitMessage() = 退出消息循环
pumpMessage() = 处理消息
isDialogMessage(hwnd,msg) = 处理对话框控制键消息
delay(__) = 延时n毫秒\n如果不需要消息循环时,建议使用sleep函数
end intellisense**/
