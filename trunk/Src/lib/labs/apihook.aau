namespace labs {
	
	apihook = class {
		ctor (dll, name, func, args) {
			this.m_dll = dll;
			this.m_name = name;
			var func = ..raw.tostdcall(func, args);
			var struct = { pointer ptr = func };
			this.m_func = ..raw.convert(struct, struct).ptr;
			this.m_args = args;
		}
		install = function () {
			var hLibModule = LoadLibrary(this.m_dll);
			if (!hLibModule) {
				error("找不到指定的dll!", 2);
			}
			var pFunAddress = GetProcAddress(hLibModule, this.m_name);
			if (!pFunAddress) {
				FreeLibrary(hLibModule);
				error("找不到指定的函数!", 2);
			}
			var re, dwOldProtect = VirtualProtect(pFunAddress, 5, 0x40/*_PAGE_EXECUTE_READWRITE*/, 0);
			if (!re) {
				FreeLibrary(hLibModule);
				error("修改内存属性失败!", 2);
			}
			this.m_dwOldProtect = dwOldProtect;
			this.m_pFunAddress = pFunAddress;
			var pData = ::GlobalAlloc(0x0/*_GMEM_FIXED*/, 10);
			writeMemStr(Ptr2Str(pFunAddress, 5) + '\xE9', pData, 6);
			var addr = tonumber(this.m_func) - (tonumber(pFunAddress) + 5);
			writeMemStr('\xE9' + ..raw.convert({int n=addr},{byte s[4]}).s, pFunAddress, 5); // 修改API入口前 5bytes
			var addr = tonumber(pFunAddress) + 5 - (tonumber(pData) + 10);
			writeMemStr(..raw.convert({int n=addr},{byte s[4]}).s, topointer(tonumber(pData) + 6), 4);
			this.m_addrData = pData;
			var exe = ..raw.loadDll();
			this.call = exe.api(pData, this.m_args);
			FreeLibrary(hLibModule);
		}
		uninstall = function () {
			if (!this.m_pFunAddress) {
				return;
			}
			writeMemStr(..raw.convert(this.m_addrData,{byte s[10]}).s, this.m_pFunAddress, 5);
			VirtualProtect(this.m_pFunAddress, 5, this.m_dwOldProtect, 0);
			this.pFunAddress = null;
			::GlobalFree(this.m_addrData);
			this.m_addrData = 0;
		}
	}
	
}

namespace labs.apihook {
	LoadLibrary = ::Kernel32.api("LoadLibraryA","pointer(string lpLibFileName)");
	FreeLibrary = ::Kernel32.api("FreeLibrary","int(pointer hLibModule)");
	GetProcAddress = ::Kernel32.api("GetProcAddress","pointer(pointer hModule,string lpProcName)");
	CopyMemoryByStr = ::Kernel32.api("RtlMoveMemory","void(int& Destination,int Source,INT Length)");
	CopyMemoryStr = ::Kernel32.api("RtlMoveMemory","void(string& Destination,pointer Source,INT Length)");
	CopyMemoryByInt = ::Kernel32.api("RtlMoveMemory","void(int& Destination,int Source,INT Length)");
	CopyMemoryInt = ::Kernel32.api("RtlMoveMemory","void(int& Destination,pointer Source,INT Length)");
	VirtualProtect = ::Kernel32.api("VirtualProtect","int(pointer lpAddress,INT dwSize,INT flNewProtect,INT& lpflOldProtect)");
	WriteProcessMemoryByStr = ::Kernel32.api("WriteProcessMemory","int(int hProcess,pointer lpBaseAddress,string lpBuffer,INT nSize,INT lpNumberOfBytesWritten)");
	CloseHandle = ::Kernel32.api("CloseHandle","int(pointer hObject)");
	lstrcpynByStr = ::Kernel32.api("lstrcpyn","int(string &lpString1,string &lpString2,int iMaxLength)");
	lstrcpynByInt = ::Kernel32.api("lstrcpyn","int(int &lpString1,int &lpString2,int iMaxLength)");
	lstrcpynByPtr = ::Kernel32.api("lstrcpyn","int(pointer &lpString1,pointer &lpString2,int iMaxLength)");
	lstrcpyn2Ptr = ::Kernel32.api("lstrcpyn","pointer(pointer &lpString1,pointer &lpString2,int iMaxLength)");
	
	writeMemStr = function (data, ptr, size) {
		return WriteProcessMemoryByStr(-1, ptr, data, size, 0) != 0;
	}
	Ptr2Str = function (ptr, size) {
		return CopyMemoryStr(size, ptr, size);
	}
	Ptr2Int = function (ptr, size) {
		return CopyMemoryInt(size, ptr, size);
	}
}